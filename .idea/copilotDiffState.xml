<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.thomasp.pong&quot;&#10;    compileSdk = 35&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.thomasp.pong&quot;&#10;        minSdk = 34&#10;        targetSdk = 35&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    buildTypes {&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_11&#10;        targetCompatibility = JavaVersion.VERSION_11&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;11&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.ui)&#10;    implementation(libs.androidx.ui.graphics)&#10;    implementation(libs.androidx.ui.tooling.preview)&#10;    implementation(libs.androidx.material3)&#10;    implementation(files(&quot;libs/glyphsdk_0606.aar&quot;))&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#10;    debugImplementation(libs.androidx.ui.tooling)&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#10;}" />
              <option name="updatedContent" value="plugins {&#13;&#10;    alias(libs.plugins.android.application)&#13;&#10;    alias(libs.plugins.kotlin.android)&#13;&#10;    alias(libs.plugins.kotlin.compose)&#13;&#10;}&#13;&#10;&#13;&#10;android {&#13;&#10;    namespace = &quot;com.thomasp.pong&quot;&#13;&#10;    compileSdk = 35&#13;&#10;&#13;&#10;    defaultConfig {&#13;&#10;        applicationId = &quot;com.thomasp.pong&quot;&#13;&#10;        minSdk = 34&#13;&#10;        targetSdk = 35&#13;&#10;        versionCode = 1&#13;&#10;        versionName = &quot;1.0&quot;&#13;&#10;&#13;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#13;&#10;    }&#13;&#10;&#13;&#10;    buildTypes {&#13;&#10;        release {&#13;&#10;            isMinifyEnabled = false&#13;&#10;            proguardFiles(&#13;&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#13;&#10;                &quot;proguard-rules.pro&quot;&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;    compileOptions {&#13;&#10;        sourceCompatibility = JavaVersion.VERSION_11&#13;&#10;        targetCompatibility = JavaVersion.VERSION_11&#13;&#10;    }&#13;&#10;    kotlinOptions {&#13;&#10;        jvmTarget = &quot;11&quot;&#13;&#10;    }&#13;&#10;    buildFeatures {&#13;&#10;        compose = true&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;dependencies {&#13;&#10;&#13;&#10;    implementation(libs.androidx.core.ktx)&#13;&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#13;&#10;    implementation(libs.androidx.activity.compose)&#13;&#10;    implementation(platform(libs.androidx.compose.bom))&#13;&#10;    implementation(libs.androidx.ui)&#13;&#10;    implementation(libs.androidx.ui.graphics)&#13;&#10;    implementation(libs.androidx.ui.tooling.preview)&#13;&#10;    implementation(libs.androidx.material3)&#13;&#10;    implementation(files(&quot;libs/glyphsdk_0606.aar&quot;))&#13;&#10;    implementation(&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;)&#13;&#10;    implementation(&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;)&#13;&#10;    implementation(&quot;com.google.code.gson:gson:2.10.1&quot;)&#13;&#10;    testImplementation(libs.junit)&#13;&#10;    androidTestImplementation(libs.androidx.junit)&#13;&#10;    androidTestImplementation(libs.androidx.espresso.core)&#13;&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#13;&#10;    androidTestImplementation(libs.androidx.ui.test.junit4)&#13;&#10;    debugImplementation(libs.androidx.ui.tooling)&#13;&#10;    debugImplementation(libs.androidx.ui.test.manifest)&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/AndroidManifest.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/AndroidManifest.xml" />
              <option name="originalContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#10;&#10;    &lt;!-- Required permissions --&gt;&#10;    &lt;uses-permission android:name=&quot;com.nothing.ketchum.permission.ENABLE&quot; /&gt;&#10;    &lt;uses-feature android:name=&quot;android.hardware.sensor.gyroscope&quot; /&gt;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;&#10;&#10;    &lt;application&#10;        android:allowBackup=&quot;true&quot;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#10;        android:label=&quot;@string/app_name&quot;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#10;        android:supportsRtl=&quot;true&quot;&#10;        android:theme=&quot;@style/Theme.NothingAndroidSDKDemo&quot;&gt;&#10;&#10;        &lt;activity&#10;            android:name=&quot;com.thomasp.pong.MainActivity&quot;&#10;            android:exported=&quot;true&quot;&#10;            android:theme=&quot;@style/Theme.NothingAndroidSDKDemo&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;        &lt;/activity&gt;&#10;&#10;        &lt;!-- Pong Game Service --&gt;&#10;        &lt;service&#10;            android:name=&quot;com.thomasp.pong.toys.pong.PongGameService&quot;&#10;            android:exported=&quot;true&quot;&#10;            tools:ignore=&quot;ExportedService&quot;&gt;&#10;            &lt;intent-filter&gt;&#10;                &lt;action android:name=&quot;com.nothing.glyph.TOY&quot; /&gt;&#10;            &lt;/intent-filter&gt;&#10;&#10;            &lt;meta-data&#10;                android:name=&quot;com.nothing.glyph.toy.image&quot;&#10;                android:resource=&quot;@drawable/pong_thumbnail&quot; /&gt;&#10;&#10;            &lt;meta-data&#10;                android:name=&quot;com.nothing.glyph.toy.longpress&quot;&#10;                android:value=&quot;1&quot; /&gt;&#10;&#10;            &lt;meta-data&#10;                android:name=&quot;com.nothing.glyph.toy.name&quot;&#10;                android:resource=&quot;@string/toy_name_pong&quot; /&gt;&#10;            &lt;meta-data&#10;                android:name=&quot;com.nothing.glyph.toy.summary&quot;&#10;                android:resource=&quot;@string/toy_summary_pong&quot; /&gt;&#10;        &lt;/service&gt;&#10;    &lt;/application&gt;&#10;&#10;&lt;/manifest&gt;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#13;&#10;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#13;&#10;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt;&#13;&#10;&#13;&#10;    &lt;!-- Required permissions --&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;com.nothing.ketchum.permission.ENABLE&quot; /&gt;&#13;&#10;    &lt;uses-feature android:name=&quot;android.hardware.sensor.gyroscope&quot; /&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt;&#13;&#10;    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;&#13;&#10;&#13;&#10;    &lt;application&#13;&#10;        android:allowBackup=&quot;true&quot;&#13;&#10;        android:dataExtractionRules=&quot;@xml/data_extraction_rules&quot;&#13;&#10;        android:fullBackupContent=&quot;@xml/backup_rules&quot;&#13;&#10;        android:icon=&quot;@mipmap/ic_launcher&quot;&#13;&#10;        android:label=&quot;@string/app_name&quot;&#13;&#10;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;&#13;&#10;        android:supportsRtl=&quot;true&quot;&#13;&#10;        android:theme=&quot;@style/Theme.NothingAndroidSDKDemo&quot;&gt;&#13;&#10;&#13;&#10;        &lt;activity&#13;&#10;            android:name=&quot;com.thomasp.pong.MainActivity&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            android:theme=&quot;@style/Theme.NothingAndroidSDKDemo&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;&#13;&#10;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;        &lt;/activity&gt;&#13;&#10;&#13;&#10;        &lt;!-- Pong Game Service --&gt;&#13;&#10;        &lt;service&#13;&#10;            android:name=&quot;com.thomasp.pong.toys.pong.PongGameService&quot;&#13;&#10;            android:exported=&quot;true&quot;&#13;&#10;            tools:ignore=&quot;ExportedService&quot;&gt;&#13;&#10;            &lt;intent-filter&gt;&#13;&#10;                &lt;action android:name=&quot;com.nothing.glyph.TOY&quot; /&gt;&#13;&#10;            &lt;/intent-filter&gt;&#13;&#10;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;com.nothing.glyph.toy.image&quot;&#13;&#10;                android:resource=&quot;@drawable/pong_thumbnail&quot; /&gt;&#13;&#10;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;com.nothing.glyph.toy.longpress&quot;&#13;&#10;                android:value=&quot;1&quot; /&gt;&#13;&#10;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;com.nothing.glyph.toy.name&quot;&#13;&#10;                android:resource=&quot;@string/toy_name_pong&quot; /&gt;&#13;&#10;            &lt;meta-data&#13;&#10;                android:name=&quot;com.nothing.glyph.toy.summary&quot;&#13;&#10;                android:resource=&quot;@string/toy_summary_pong&quot; /&gt;&#13;&#10;        &lt;/service&gt;&#13;&#10;    &lt;/application&gt;&#13;&#10;&#13;&#10;&lt;/manifest&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/PongSettings.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/PongSettings.kt" />
              <option name="updatedContent" value="package com.nothinglondon.pong&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;&#10;object PongSettings {&#10;    var soundEnabled by mutableStateOf(true)&#10;    var hapticEnabled by mutableStateOf(true)&#10;    var howToPlayExpanded by mutableStateOf(false)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/toys/pong/PongGameService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/toys/pong/PongGameService.kt" />
              <option name="originalContent" value="package com.nothinglondon.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.pong.PongSettings&#10;import com.nothinglondon.pong.R&#10;import com.nothinglondon.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.pong.toys.pong.game.GameState&#10;import com.nothinglondon.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 150L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.3f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;&#10;        // Store previous position for collision detection&#10;        val prevX = ball.x&#10;        val prevY = ball.y&#10;&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24)&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the non-scoring zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside non-scoring zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][x] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nothinglondon.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.pong.PongSettings&#10;import com.nothinglondon.pong.R&#10;import com.nothinglondon.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.pong.toys.pong.game.GameState&#10;import com.nothinglondon.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 150L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.3f&#10;&#10;        // Wall constants&#10;        private val TOP_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 1) }.toSet()&#10;        private val BOTTOM_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 23) }.toSet()&#10;        private val ALL_WALL_CELLS = TOP_WALL_CELLS + BOTTOM_WALL_CELLS&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Check for collisions with specific wall cells&#10;        var hitWall = false&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val checkX = (ballLeft + dx).toInt()&#10;                val checkY = (ballTop + dy).toInt()&#10;                if (ALL_WALL_CELLS.contains(Pair(checkX, checkY))) {&#10;                    hitWall = true&#10;                    break&#10;                }&#10;            }&#10;            if (hitWall) break&#10;        }&#10;&#10;        if (hitWall) {&#10;            ball.reverseY()&#10;            // Move ball away from wall to prevent sticking&#10;            if (ballTop &lt;= 2) { // Near top wall&#10;                ball.y = 2f&#10;            } else { // Near bottom wall&#10;                ball.y = 22f - BALL_SIZE&#10;            }&#10;            return&#10;        }&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24) - only score if not in wall area&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the wall zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside wall zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][x] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/Ball.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/Ball.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;data class Ball(&#10;    var x: Float = 12f,  // Start in center&#10;    var y: Float = 12f,&#10;    var velocityX: Float = 0.2f,&#10;    var velocityY: Float = 0.2f&#10;) {&#10;    fun update() {&#10;        x += velocityX&#10;        y += velocityY&#10;    }&#10;&#10;    fun reverseX() {&#10;        velocityX = -velocityX&#10;    }&#10;&#10;    fun reverseY() {&#10;        velocityY = -velocityY&#10;    }&#10;&#10;    fun getPosition(): Pair&lt;Int, Int&gt; = Pair(x.toInt(), y.toInt())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt" />
              <option name="originalContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt.new">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt.new" />
              <option name="originalContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 45f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.01f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                isPlaying = true&#10;                gameState = GameState.PLAYING&#10;                ball.start()&#10;                updateDisplay()  // Ensure immediate update&#10;            }&#10;            GameState.PLAYING -&gt; {&#10;                // Calibrate using the roll axis as before&#10;                SensorManager.getRotationMatrixFromVector(rotationMatrix, orientationAngles)&#10;                SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;                calibrationAngle = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1  // Center position&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Calculate scroll positions for two copies of the text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;  // Added padding&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 2)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy immediately after the first&#10;            val x2 = x1 + textWidth&#10;            drawText(matrix, scrollText, x2, 16)&#10;&#10;            // Update scroll position&#10;            startScreenScrollPosition += SCROLL_SPEED&#10;            if (startScreenScrollPosition &gt;= textWidth) {&#10;                startScreenScrollPosition = 0f&#10;            }&#10;&#10;            // Send the matrix to display&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;&#10;            // Keep updating the display for scrolling text&#10;            if (gameState == GameState.START_SCREEN) {&#10;                gameScope.launch {&#10;                    delay(16)&#10;                    updateDisplay()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            val pitch = Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // -20 to 20&#10;            val roll = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()   // -180 to 180&#10;&#10;            // Base movement from pitch with reduced range&#10;            val normalizedPitch = (pitch.coerceIn(-20f, 20f) + 20f) / 40f  // 0 to 1&#10;            val basePitchPosition = normalizedPitch * (paddlePositions.size - 1)&#10;&#10;            // Update paddle position&#10;            pointerIndex = basePitchPosition.roundToInt()&#10;                .coerceIn(0, paddlePositions.size - 1)&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 45f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.01f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                isPlaying = true&#10;                gameState = GameState.PLAYING&#10;                ball.start()&#10;                updateDisplay()  // Ensure immediate update&#10;            }&#10;            GameState.PLAYING -&gt; {&#10;                // Calibrate using the roll axis as before&#10;                SensorManager.getRotationMatrixFromVector(rotationMatrix, orientationAngles)&#10;                SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;                calibrationAngle = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1  // Center position&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Calculate scroll positions for two copies of the text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;  // Added padding&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 2)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy immediately after the first&#10;            val x2 = x1 + textWidth&#10;            drawText(matrix, scrollText, x2, 16)&#10;&#10;            // Update scroll position&#10;            startScreenScrollPosition += SCROLL_SPEED&#10;            if (startScreenScrollPosition &gt;= textWidth) {&#10;                startScreenScrollPosition = 0f&#10;            }&#10;&#10;            // Send the matrix to display&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;&#10;            // Keep updating the display for scrolling text&#10;            if (gameState == GameState.START_SCREEN) {&#10;                gameScope.launch {&#10;                    delay(16)&#10;                    updateDisplay()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            val pitch = Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // -90 to 90&#10;            val roll = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()   // -180 to 180&#10;&#10;            // Adjust roll based on calibration&#10;            val adjustedRoll = (roll - calibrationAngle).coerceIn(-90f, 90f)&#10;            &#10;            // Combine pitch and roll for more natural movement&#10;            val combinedAngle = (pitch * 0.7f + adjustedRoll * 0.3f).coerceIn(-45f, 45f)&#10;            &#10;            // Normalize to 0-1 range with smooth acceleration&#10;            val normalizedPosition = ((combinedAngle + 45f) / 90f).coerceIn(0f, 1f)&#10;            &#10;            // Apply smoothing using paddlePosition and velocity&#10;            val targetPosition = normalizedPosition * (paddlePositions.size - 1)&#10;            val distance = targetPosition - paddlePosition&#10;            &#10;            // Update velocity with smoothing&#10;            paddleVelocity = paddleVelocity * SMOOTHING_FACTOR + distance * (1 - SMOOTHING_FACTOR)&#10;            paddlePosition = (paddlePosition + paddleVelocity).coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;            &#10;            // Update pointer index from smoothed position&#10;            pointerIndex = paddlePosition.roundToInt().coerceIn(0, paddlePositions.size - 1)&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/GameState.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong.game&#10;&#10;enum class GameState {&#10;    START_SCREEN,    // Showing level information&#10;    PLAYING,         // Active game&#10;    LEVEL_UP,       // Player won&#10;    GAME_OVER,      // Player lost&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/LevelManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/LevelManager.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class LevelManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongGame&quot;, Context.MODE_PRIVATE)&#10;    &#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        get() = prefs.getInt(&quot;highest_level&quot;, 0)&#10;        private set(value) = prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 15% for levels 1-5, then decrease by 0.5% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.15f&#10;            else -&gt; maxOf(0.01f, 0.15f - (currentLevel - 5) * 0.005f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/MainActivity.kt" />
              <option name="originalContent" value="package com.thomasp.pong&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.foundation.Image&#10;import androidx.activity.compose.BackHandler&#10;import com.thomasp.pong.ui.theme.PongTypography&#10;import com.thomasp.pong.api.LeaderboardService&#10;import com.thomasp.pong.data.UserPreferences&#10;import com.thomasp.pong.ui.LeaderboardScreen&#10;import com.thomasp.pong.ui.UsernameDialog&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private lateinit var leaderboardService: LeaderboardService&#10;    private lateinit var userPreferences: UserPreferences&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        leaderboardService = LeaderboardService(this)&#10;        userPreferences = UserPreferences(this)&#10;        enableEdgeToEdge()&#10;        setContent {&#10;            MaterialTheme(&#10;                colorScheme = darkColorScheme(&#10;                    primary = Color.White,&#10;                    onPrimary = Color.Black,&#10;                    surface = Color(0xFF141414),&#10;                    onSurface = Color.White,&#10;                    background = Color(0xFF141414),&#10;                    onBackground = Color.White&#10;                ),&#10;                typography = PongTypography&#10;            ) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    var showLeaderboard by remember { mutableStateOf(false) }&#10;                    var showUsernameDialog by remember { mutableStateOf(!userPreferences.hasUsername()) }&#10;&#10;                    // Show username dialog if needed&#10;                    if (showUsernameDialog) {&#10;                        UsernameDialog(&#10;                            onDismissRequest = {&#10;                                // Only allow dismissal if they already have a username&#10;                                if (userPreferences.hasUsername()) {&#10;                                    showUsernameDialog = false&#10;                                }&#10;                            },&#10;                            onConfirm = { username -&gt;&#10;                                userPreferences.setUsername(username)&#10;                                showUsernameDialog = false&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Handle system back button&#10;                    BackHandler(enabled = showLeaderboard) {&#10;                        showLeaderboard = false&#10;                    }&#10;&#10;                    if (showLeaderboard) {&#10;                        LeaderboardScreen(&#10;                            leaderboardService = leaderboardService,&#10;                            onBack = { showLeaderboard = false }&#10;                        )&#10;                    } else {&#10;                        MainScreen(&#10;                            onLeaderboardClick = { showLeaderboard = true },&#10;                            onUsernameClick = { showUsernameDialog = true }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class PongSettings {&#10;    companion object {&#10;        var soundEnabled by mutableStateOf(true)&#10;        var hapticEnabled by mutableStateOf(true)&#10;        var howToPlayExpanded by mutableStateOf(false)&#10;        var installationExpanded by mutableStateOf(false)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    modifier: Modifier = Modifier,&#10;    onLeaderboardClick: () -&gt; Unit = {},&#10;    onUsernameClick: () -&gt; Unit = {}&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.TopCenter&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            // Title&#10;            Text(&#10;                text = &quot;Pong&quot;,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier.padding(top = 40.dp)&#10;            )&#10;&#10;            Image(&#10;                painter = painterResource(R.drawable.pong_thumbnail),&#10;                contentDescription = &quot;Pong Preview&quot;,&#10;                modifier = Modifier.size(200.dp)&#10;            )&#10;&#10;            // Buttons section&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                Button(&#10;                    onClick = onLeaderboardClick,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Leaderboard&quot;)&#10;                }&#10;&#10;                OutlinedButton(&#10;                    onClick = onUsernameClick,&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    Text(&quot;Change Username&quot;)&#10;                }&#10;            }&#10;&#10;            // Settings List&#10;            Surface(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = MaterialTheme.colorScheme.surface,&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    // Sound Toggle&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 0.dp, vertical = 4.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Sound&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Switch(&#10;                            checked = PongSettings.soundEnabled,&#10;                            onCheckedChange = { PongSettings.soundEnabled = it }&#10;                        )&#10;                    }&#10;&#10;//                HorizontalDivider(&#10;//                    color = Color.Gray.copy(alpha = 0.2f),&#10;//                    thickness = 1.dp&#10;//                )&#10;&#10;                    // Haptic Toggle&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 0.dp, vertical = 4.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Haptic Vibration&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Switch(&#10;                            checked = PongSettings.hapticEnabled,&#10;                            onCheckedChange = { PongSettings.hapticEnabled = it }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // How to Use Section&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;How to Use&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;&#10;                // Installation Section&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { PongSettings.installationExpanded = !PongSettings.installationExpanded },&#10;                    border = BorderStroke(1.dp, Color.Gray.copy(alpha = 0.3f)),&#10;                    color = MaterialTheme.colorScheme.surface,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.fillMaxWidth()) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Installation&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                            Icon(&#10;                                imageVector = if (PongSettings.installationExpanded) {&#10;                                    Icons.Default.KeyboardArrowUp&#10;                                } else {&#10;                                    Icons.Default.KeyboardArrowDown&#10;                                },&#10;                                contentDescription = &quot;Expand&quot;&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(visible = PongSettings.installationExpanded) {&#10;                            Column(&#10;                                modifier = Modifier.padding(&#10;                                    start = 16.dp,&#10;                                    end = 16.dp,&#10;                                    bottom = 16.dp&#10;                                ),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                HorizontalDivider(&#10;                                    color = Color.Gray.copy(alpha = 0.3f),&#10;                                    thickness = 1.dp&#10;                                )&#10;                                Text(&quot; Settings &gt; Glyph Interface &gt; Glyph Toys&quot;)&#10;                                Text(&quot; Select reorder icon (top right)&quot;)&#10;                                Text(&quot; Drag Pong to be an active toy&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Gameplay Section&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { PongSettings.howToPlayExpanded = !PongSettings.howToPlayExpanded },&#10;                    border = BorderStroke(1.dp, Color.Gray.copy(alpha = 0.3f)),&#10;                    color = MaterialTheme.colorScheme.surface,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.fillMaxWidth()) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Gameplay&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                            Icon(&#10;                                imageVector = if (PongSettings.howToPlayExpanded) {&#10;                                    Icons.Default.KeyboardArrowUp&#10;                                } else {&#10;                                    Icons.Default.KeyboardArrowDown&#10;                                },&#10;                                contentDescription = &quot;Expand&quot;&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(visible = PongSettings.howToPlayExpanded) {&#10;                            Column(&#10;                                modifier = Modifier.padding(&#10;                                    start = 16.dp,&#10;                                    end = 16.dp,&#10;                                    bottom = 16.dp&#10;                                ),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                HorizontalDivider(&#10;                                    color = Color.Gray.copy(alpha = 0.3f),&#10;                                    thickness = 1.dp&#10;                                )&#10;                                Text(&quot; Long press to start Pong&quot;)&#10;                                Text(&quot; Tilt phone to control paddle&quot;)&#10;                                Text(&quot; Avoid missing the ball and try to beat the bot&quot;)&#10;                                Text(&quot; If you score, you will level up and it gets harder&quot;)&#10;                                Text(&quot; When the bot beats you, back to level one&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Attribution&#10;            Text(&#10;                text = &quot;Made by Thomas&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = Color.Gray,&#10;                modifier = Modifier.padding(top = 8.dp, bottom = 24.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.foundation.BorderStroke&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.KeyboardArrowDown&#10;import androidx.compose.material.icons.filled.KeyboardArrowUp&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.foundation.Image&#10;import androidx.activity.compose.BackHandler&#10;import com.thomasp.pong.ui.theme.PongTypography&#10;import com.thomasp.pong.api.LeaderboardService&#10;import com.thomasp.pong.data.UserPreferences&#10;import com.thomasp.pong.ui.LeaderboardScreen&#10;import kotlinx.coroutines.MainScope&#10;import kotlinx.coroutines.launch&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private lateinit var leaderboardService: LeaderboardService&#10;    private lateinit var userPreferences: UserPreferences&#10;    private val mainScope = MainScope()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        leaderboardService = LeaderboardService(this)&#10;        userPreferences = UserPreferences(this)&#10;        enableEdgeToEdge()&#10;&#10;        // Initialize username in background (no dialog, no loading screen)&#10;        mainScope.launch {&#10;            leaderboardService.ensureUsername()&#10;        }&#10;&#10;        setContent {&#10;            MaterialTheme(&#10;                colorScheme = darkColorScheme(&#10;                    primary = Color.White,&#10;                    onPrimary = Color.Black,&#10;                    surface = Color(0xFF141414),&#10;                    onSurface = Color.White,&#10;                    background = Color(0xFF141414),&#10;                    onBackground = Color.White&#10;                ),&#10;                typography = PongTypography&#10;            ) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    var showLeaderboard by remember { mutableStateOf(false) }&#10;&#10;                    // Handle system back button&#10;                    BackHandler(enabled = showLeaderboard) {&#10;                        showLeaderboard = false&#10;                    }&#10;&#10;                    if (showLeaderboard) {&#10;                        LeaderboardScreen(&#10;                            leaderboardService = leaderboardService,&#10;                            onBack = { showLeaderboard = false }&#10;                        )&#10;                    } else {&#10;                        MainScreen(&#10;                            onLeaderboardClick = { showLeaderboard = true }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;class PongSettings {&#10;    companion object {&#10;        var soundEnabled by mutableStateOf(true)&#10;        var hapticEnabled by mutableStateOf(true)&#10;        var howToPlayExpanded by mutableStateOf(false)&#10;        var installationExpanded by mutableStateOf(false)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun MainScreen(&#10;    modifier: Modifier = Modifier,&#10;    onLeaderboardClick: () -&gt; Unit = {}&#10;) {&#10;    Box(&#10;        modifier = modifier.fillMaxSize(),&#10;        contentAlignment = Alignment.TopCenter&#10;    ) {&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp),&#10;            horizontalAlignment = Alignment.CenterHorizontally,&#10;            verticalArrangement = Arrangement.spacedBy(24.dp)&#10;        ) {&#10;            // Title&#10;            Text(&#10;                text = &quot;Pong&quot;,&#10;                fontSize = 24.sp,&#10;                fontWeight = FontWeight.Bold,&#10;                modifier = Modifier.padding(top = 40.dp)&#10;            )&#10;&#10;            Image(&#10;                painter = painterResource(R.drawable.pong_thumbnail),&#10;                contentDescription = &quot;Pong Preview&quot;,&#10;                modifier = Modifier.size(200.dp)&#10;            )&#10;&#10;            // Buttons section&#10;            Button(&#10;                onClick = onLeaderboardClick,&#10;                modifier = Modifier.fillMaxWidth()&#10;            ) {&#10;                Text(&quot;Leaderboard&quot;)&#10;            }&#10;&#10;            // Settings List&#10;            Surface(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                color = MaterialTheme.colorScheme.surface,&#10;                shape = RoundedCornerShape(12.dp)&#10;            ) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth()&#10;                ) {&#10;                    // Sound Toggle&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 0.dp, vertical = 4.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Sound&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Switch(&#10;                            checked = PongSettings.soundEnabled,&#10;                            onCheckedChange = { PongSettings.soundEnabled = it }&#10;                        )&#10;                    }&#10;&#10;//                HorizontalDivider(&#10;//                    color = Color.Gray.copy(alpha = 0.2f),&#10;//                    thickness = 1.dp&#10;//                )&#10;&#10;                    // Haptic Toggle&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(horizontal = 0.dp, vertical = 4.dp),&#10;                        horizontalArrangement = Arrangement.SpaceBetween,&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;Haptic Vibration&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge&#10;                        )&#10;                        Switch(&#10;                            checked = PongSettings.hapticEnabled,&#10;                            onCheckedChange = { PongSettings.hapticEnabled = it }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // How to Use Section&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;How to Use&quot;,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    fontWeight = FontWeight.SemiBold&#10;                )&#10;&#10;                // Installation Section&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { PongSettings.installationExpanded = !PongSettings.installationExpanded },&#10;                    border = BorderStroke(1.dp, Color.Gray.copy(alpha = 0.3f)),&#10;                    color = MaterialTheme.colorScheme.surface,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.fillMaxWidth()) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Installation&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                            Icon(&#10;                                imageVector = if (PongSettings.installationExpanded) {&#10;                                    Icons.Default.KeyboardArrowUp&#10;                                } else {&#10;                                    Icons.Default.KeyboardArrowDown&#10;                                },&#10;                                contentDescription = &quot;Expand&quot;&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(visible = PongSettings.installationExpanded) {&#10;                            Column(&#10;                                modifier = Modifier.padding(&#10;                                    start = 16.dp,&#10;                                    end = 16.dp,&#10;                                    bottom = 16.dp&#10;                                ),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                HorizontalDivider(&#10;                                    color = Color.Gray.copy(alpha = 0.3f),&#10;                                    thickness = 1.dp&#10;                                )&#10;                                Text(&quot; Settings &gt; Glyph Interface &gt; Glyph Toys&quot;)&#10;                                Text(&quot; Select reorder icon (top right)&quot;)&#10;                                Text(&quot; Drag Pong to be an active toy&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Gameplay Section&#10;                Surface(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable { PongSettings.howToPlayExpanded = !PongSettings.howToPlayExpanded },&#10;                    border = BorderStroke(1.dp, Color.Gray.copy(alpha = 0.3f)),&#10;                    color = MaterialTheme.colorScheme.surface,&#10;                    shape = RoundedCornerShape(12.dp)&#10;                ) {&#10;                    Column(modifier = Modifier.fillMaxWidth()) {&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;Gameplay&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge&#10;                            )&#10;                            Icon(&#10;                                imageVector = if (PongSettings.howToPlayExpanded) {&#10;                                    Icons.Default.KeyboardArrowUp&#10;                                } else {&#10;                                    Icons.Default.KeyboardArrowDown&#10;                                },&#10;                                contentDescription = &quot;Expand&quot;&#10;                            )&#10;                        }&#10;&#10;                        AnimatedVisibility(visible = PongSettings.howToPlayExpanded) {&#10;                            Column(&#10;                                modifier = Modifier.padding(&#10;                                    start = 16.dp,&#10;                                    end = 16.dp,&#10;                                    bottom = 16.dp&#10;                                ),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                HorizontalDivider(&#10;                                    color = Color.Gray.copy(alpha = 0.3f),&#10;                                    thickness = 1.dp&#10;                                )&#10;                                Text(&quot; Long press to start Pong&quot;)&#10;                                Text(&quot; Tilt phone to control paddle&quot;)&#10;                                Text(&quot; Avoid missing the ball and try to beat the bot&quot;)&#10;                                Text(&quot; If you score, you will level up and it gets harder&quot;)&#10;                                Text(&quot; When the bot beats you, back to level one&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Attribution&#10;            Text(&#10;                text = &quot;Made by Thomas&quot;,&#10;                style = MaterialTheme.typography.bodySmall,&#10;                color = Color.Gray,&#10;                modifier = Modifier.padding(top = 8.dp, bottom = 24.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/PongApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/PongApplication.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/LeaderboardApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/LeaderboardApi.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.api&#10;&#10;import okhttp3.ResponseBody&#10;import retrofit2.Response&#10;import retrofit2.http.GET&#10;import retrofit2.http.POST&#10;import retrofit2.http.Body&#10;import retrofit2.http.Query&#10;&#10;data class LeaderboardEntry(&#10;    val user_id: String,&#10;    val username: String,&#10;    val score: Int&#10;)&#10;&#10;data class LeaderboardResponse(&#10;    val top: List&lt;LeaderboardEntry&gt;,&#10;    val score: Int,&#10;    val inTop: Boolean,&#10;    val position: Int?&#10;)&#10;&#10;data class ScoreRequest(&#10;    val user_id: String,&#10;    val username: String,&#10;    val score: Int&#10;)&#10;&#10;data class SuccessResponse(&#10;    val success: Boolean,&#10;    val error: String? = null&#10;)&#10;&#10;data class UsernameAvailabilityResponse(&#10;    val available: Boolean&#10;)&#10;&#10;data class SetUsernameRequest(&#10;    val user_id: String,&#10;    val username: String&#10;)&#10;&#10;interface LeaderboardApi {&#10;    @GET(&quot;api/leaderboard&quot;)&#10;    suspend fun getLeaderboard(@Query(&quot;user_id&quot;) userId: String? = null): LeaderboardResponse&#10;&#10;    @POST(&quot;api/leaderboard&quot;)&#10;    suspend fun submitScore(@Body request: ScoreRequest): SuccessResponse&#10;&#10;    @GET(&quot;api/username/check&quot;)&#10;    suspend fun checkUsername(@Query(&quot;username&quot;) username: String): UsernameAvailabilityResponse&#10;&#10;    @POST(&quot;api/username/set&quot;)&#10;    suspend fun setUsername(@Body request: SetUsernameRequest): SuccessResponse&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/LeaderboardService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/LeaderboardService.kt" />
              <option name="originalContent" value="package com.thomasp.pong.api&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import okhttp3.OkHttpClient&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.UUID&#10;&#10;class LeaderboardService(context: Context) {&#10;    private val baseUrl = &quot;https://pong-leaderboard-api.vercel.app/&quot;  // Remove /api/leaderboard from base URL&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongPrefs&quot;, Context.MODE_PRIVATE)&#10;    private val USER_ID_KEY = &quot;user_id&quot;&#10;&#10;    private val api = Retrofit.Builder()&#10;        .baseUrl(baseUrl)&#10;        .client(OkHttpClient())&#10;        .addConverterFactory(GsonConverterFactory.create())&#10;        .build()&#10;        .create(LeaderboardApi::class.java)&#10;&#10;    fun getUserId(): String {&#10;        var userId = prefs.getString(USER_ID_KEY, null)&#10;        if (userId == null) {&#10;            userId = UUID.randomUUID().toString()&#10;            prefs.edit().putString(USER_ID_KEY, userId).apply()&#10;        }&#10;        return userId&#10;    }&#10;&#10;    suspend fun getLeaderboard(): Result&lt;LeaderboardResponse&gt; {&#10;        return try {&#10;            val response = api.getLeaderboard(getUserId())&#10;            Result.success(response)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.api&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import kotlin.random.Random&#10;import okhttp3.OkHttpClient&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;import java.util.UUID&#10;&#10;class LeaderboardService(context: Context) {&#10;    private val baseUrl = &quot;https://pong-leaderboard-api.vercel.app/&quot;&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongPrefs&quot;, Context.MODE_PRIVATE)&#10;    private val USER_ID_KEY = &quot;user_id&quot;&#10;    private val USERNAME_KEY = &quot;username&quot;&#10;&#10;    private val api = Retrofit.Builder()&#10;        .baseUrl(baseUrl)&#10;        .client(OkHttpClient())&#10;        .addConverterFactory(GsonConverterFactory.create())&#10;        .build()&#10;        .create(LeaderboardApi::class.java)&#10;&#10;    fun getUserId(): String {&#10;        var userId = prefs.getString(USER_ID_KEY, null)&#10;        if (userId == null) {&#10;            userId = UUID.randomUUID().toString()&#10;            prefs.edit().putString(USER_ID_KEY, userId).apply()&#10;        }&#10;        return userId&#10;    }&#10;&#10;    private fun generateRandomUsername(): String {&#10;        return &quot;Player${String.format(&quot;%04d&quot;, Random.nextInt(10000))}&quot;&#10;    }&#10;&#10;    suspend fun ensureUsername(): String {&#10;        var storedUsername = getStoredUsername()&#10;        if (storedUsername == null) {&#10;            // Try up to 10 times to find an available username&#10;            for (attempt in 1..10) {&#10;                val newUsername = generateRandomUsername()&#10;                if (checkUsernameAvailability(newUsername).getOrNull() == true) {&#10;                    // Username is available, try to set it&#10;                    val result = setUsername(newUsername)&#10;                    if (result.isSuccess) {&#10;                        storedUsername = newUsername&#10;                        return storedUsername&#10;                    }&#10;                }&#10;            }&#10;            // If we still don't have a username after 10 attempts, use user ID as fallback&#10;            if (storedUsername == null) {&#10;                val fallbackUsername = &quot;Player${getUserId().take(4)}&quot;&#10;                val result = setUsername(fallbackUsername)&#10;                if (result.isSuccess) {&#10;                    storedUsername = fallbackUsername&#10;                }&#10;            }&#10;        }&#10;        return storedUsername ?: &quot;Unknown&quot;&#10;    }&#10;&#10;    fun getStoredUsername(): String? {&#10;        return prefs.getString(USERNAME_KEY, null)&#10;    }&#10;&#10;    private fun storeUsername(username: String) {&#10;        prefs.edit().putString(USERNAME_KEY, username).apply()&#10;    }&#10;&#10;    suspend fun checkUsernameAvailability(username: String): Result&lt;Boolean&gt; {&#10;        return try {&#10;            val response = api.checkUsername(username)&#10;            Result.success(response.available)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun setUsername(username: String): Result&lt;SuccessResponse&gt; {&#10;        return try {&#10;            val request = SetUsernameRequest(getUserId(), username)&#10;            val response = api.setUsername(request)&#10;            if (response.success) {&#10;                storeUsername(username)&#10;            }&#10;            Result.success(response)&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun getLeaderboard(): Result&lt;LeaderboardResponse&gt; {&#10;        return try {&#10;            Result.success(api.getLeaderboard(getUserId()))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;&#10;    suspend fun submitScore(username: String, score: Int): Result&lt;SuccessResponse&gt; {&#10;        return try {&#10;            val request = ScoreRequest(getUserId(), username, score)&#10;            Result.success(api.submitScore(request))&#10;        } catch (e: Exception) {&#10;            Result.failure(e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/ScoreApi.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/ScoreApi.kt" />
              <option name="updatedContent" value="package com.thomasp.pong.api&#10;&#10;import retrofit2.Response&#10;import retrofit2.http.Body&#10;import retrofit2.http.POST&#10;&#10;data class ScoreSubmission(&#10;    val user_id: String,&#10;    val username: String,&#10;    val score: Int&#10;)&#10;&#10;interface ScoreApi {&#10;    @POST(&quot;api/leaderboard&quot;)&#10;    suspend fun submitScore(@Body score: ScoreSubmission): Response&lt;Unit&gt;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/ScoreService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/api/ScoreService.kt" />
              <option name="updatedContent" value="package com.thomasp.pong.api&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.thomasp.pong.data.UserPreferences&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import okhttp3.OkHttpClient&#10;import retrofit2.Retrofit&#10;import retrofit2.converter.gson.GsonConverterFactory&#10;&#10;class ScoreService(context: Context) {&#10;    private val userPreferences = UserPreferences(context)&#10;    private val baseUrl = &quot;https://glyph-matrix-pong.vercel.app/&quot;&#10;    &#10;    private val api = Retrofit.Builder()&#10;        .baseUrl(baseUrl)&#10;        .client(OkHttpClient())&#10;        .addConverterFactory(GsonConverterFactory.create())&#10;        .build()&#10;        .create(ScoreApi::class.java)&#10;&#10;    suspend fun submitScore(score: Int) {&#10;        val userId = userPreferences.getUserId()&#10;        val username = userPreferences.getUsername()&#10;&#10;        if (username != null) {&#10;            try {&#10;                withContext(Dispatchers.IO) {&#10;                    api.submitScore(ScoreSubmission(userId, username, score))&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;ScoreService&quot;, &quot;Failed to submit score&quot;, e)&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/firebase/FirebaseManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/firebase/FirebaseManager.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardEntry.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardScreen.kt" />
              <option name="originalContent" value="            )&#10;    }&#10;}&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="            )&#10;    }&#10;}&#10;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardService.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/game/LevelManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/game/LevelManager.kt" />
              <option name="originalContent" value="package com.thomasp.pong.toys.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import kotlinx.coroutines.launch&#10;&#10;class LevelManager(context: Context) {&#10;    private val scoreService = ScoreService(context)&#10;&#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        private set(value) = prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;        }&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 40% for level 1, decrease to 25% by level 5, then decrease by 1% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.40f - (currentLevel - 1) * 0.03f  // 40% -&gt; 25% over first 5 levels&#10;            else -&gt; maxOf(0.01f, 0.25f - (currentLevel - 5) * 0.01f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.toys.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import com.thomasp.pong.api.LeaderboardService&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class LevelManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongGame&quot;, Context.MODE_PRIVATE)&#10;    private val leaderboardService = LeaderboardService(context)&#10;&#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        get() = prefs.getInt(&quot;highest_level&quot;, 0)&#10;        private set(value) {&#10;            prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;            // Submit score using existing LeaderboardService&#10;            CoroutineScope(Dispatchers.IO).launch {&#10;                val username = leaderboardService.ensureUsername()&#10;                leaderboardService.submitScore(username, value)&#10;            }&#10;        }&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 40% for level 1, decrease to 25% by level 5, then decrease by 1% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.40f - (currentLevel - 1) * 0.03f  // 40% -&gt; 25% over first 5 levels&#10;            else -&gt; maxOf(0.01f, 0.25f - (currentLevel - 5) * 0.01f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/ui/LeaderboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/ui/LeaderboardScreen.kt" />
              <option name="originalContent" value="package com.thomasp.pong.ui&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.expandVertically&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import com.thomasp.pong.api.LeaderboardResponse&#10;import com.thomasp.pong.api.LeaderboardService&#10;import kotlinx.coroutines.launch&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LeaderboardScreen(&#10;    leaderboardService: LeaderboardService,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    // Define medal colors that work well with dark theme&#10;    val goldColor = Color(0xFF665728)    // Darker shade of gold&#10;    val silverColor = Color(0xFF4A4A54)  // Darker shade of silver&#10;    val bronzeColor = Color(0xFF614434)  // Darker shade of bronze&#10;    var showUsernameDialog by remember { mutableStateOf(false) }&#10;    // Load username&#10;    LaunchedEffect(Unit) {&#10;        currentUsername = leaderboardService.getStoredUsername()&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        scope.launch {&#10;            isLoading = true&#10;            try {&#10;                leaderboardService.getLeaderboard()&#10;                    .onSuccess {&#10;                        leaderboardState = it&#10;                        error = null&#10;                    }&#10;                    .onFailure { e -&gt;&#10;                        error = &quot;Failed to load leaderboard: ${e.message}&quot;&#10;                        android.util.Log.e(&quot;LeaderboardScreen&quot;, &quot;Error loading leaderboard&quot;, e)&#10;                    }&#10;            } catch (e: Exception) {&#10;                error = &quot;Unexpected error: ${e.message}&quot;&#10;                android.util.Log.e(&quot;LeaderboardScreen&quot;, &quot;Unexpected error&quot;, e)&#10;            }&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;                        Icon(&#10;                            Icons.Default.ArrowBack,&#10;                            contentDescription = &quot;Back&quot;&#10;                        )&#10;                    }&#10;                },&#10;                actions = {&#10;        }&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .padding(horizontal = 16.dp, vertical = 8.dp)&#10;        ) {&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;                error != null -&gt; {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) {&#10;                        Text(&#10;                            text = error!!,&#10;                            color = MaterialTheme.colorScheme.error,&#10;                            modifier = Modifier.padding(16.dp)&#10;                        )&#10;                    }&#10;                }&#10;                leaderboardState != null -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.weight(1f),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        itemsIndexed(leaderboardState!!.top) { index, entry -&gt;&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(&#10;                                    containerColor = when {&#10;                                        entry.user_id == leaderboardService.getUserId() -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                                        index == 0 -&gt; goldColor&#10;                                        index == 1 -&gt; silverColor&#10;                                        index == 2 -&gt; bronzeColor&#10;                                        else -&gt; MaterialTheme.colorScheme.surfaceVariant&#10;                                    }&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;#${index + 1}&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium,&#10;                                            fontWeight = FontWeight.Bold&#10;                                        )&#10;                                        Text(&#10;                                            text = entry.username,&#10;                                            style = MaterialTheme.typography.titleMedium&#10;                                        )&#10;                                    }&#10;                                    Text(&#10;                                        text = entry.score.toString(),&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Show user's position if not in top 10&#10;                    if (!leaderboardState!!.inTop &amp;&amp; leaderboardState!!.position != null) {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(16.dp),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Your Position: #${leaderboardState!!.position}&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium&#10;                                )&#10;                                Text(&#10;                                    text = leaderboardState!!.score.toString(),&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                            }&#10;                        duration = SnackbarDuration.Long&#10;                    )&#10;                }&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.ui&#10;&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.expandVertically&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.animation.shrinkVertically&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.ArrowBack&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.ExperimentalComposeUiApi&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalSoftwareKeyboardController&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import com.thomasp.pong.api.LeaderboardResponse&#10;import com.thomasp.pong.api.LeaderboardService&#10;import kotlinx.coroutines.*&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun LeaderboardScreen(&#10;    leaderboardService: LeaderboardService,&#10;    onBack: () -&gt; Unit&#10;) {&#10;    // Define medal colors that work well with dark theme&#10;    val goldColor = Color(0xFF665728)    // Darker shade of gold&#10;    val silverColor = Color(0xFF4A4A54)  // Darker shade of silver&#10;    val bronzeColor = Color(0xFF614434)  // Darker shade of bronze&#10;&#10;    var leaderboardState by remember { mutableStateOf&lt;LeaderboardResponse?&gt;(null) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val scope = rememberCoroutineScope()&#10;&#10;    // Username dialog state&#10;    var showUsernameDialog by remember { mutableStateOf(false) }&#10;    var currentUsername by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Snackbar host state for showing messages&#10;    val snackbarHostState = remember { SnackbarHostState() }&#10;&#10;    // Load username and ensure it exists&#10;    LaunchedEffect(Unit) {&#10;        scope.launch {&#10;            currentUsername = leaderboardService.ensureUsername()&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(Unit) {&#10;        scope.launch {&#10;            isLoading = true&#10;            try {&#10;                leaderboardService.getLeaderboard()&#10;                    .onSuccess {&#10;                        leaderboardState = it&#10;                        error = null&#10;                    }&#10;                    .onFailure { e -&gt;&#10;                        error = &quot;Failed to load leaderboard: ${e.message}&quot;&#10;                        android.util.Log.e(&quot;LeaderboardScreen&quot;, &quot;Error loading leaderboard&quot;, e)&#10;                    }&#10;            } catch (e: Exception) {&#10;                error = &quot;Unexpected error: ${e.message}&quot;&#10;                android.util.Log.e(&quot;LeaderboardScreen&quot;, &quot;Unexpected error&quot;, e)&#10;            }&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    Scaffold(&#10;        topBar = {&#10;            TopAppBar(&#10;                title = { Text(&quot;Leaderboard&quot;) },&#10;                navigationIcon = {&#10;                    IconButton(onClick = onBack) {&#10;                        Icon(Icons.Default.ArrowBack, &quot;Back&quot;)&#10;                    }&#10;                },&#10;                actions = {&#10;                    IconButton(onClick = { showUsernameDialog = true }) {&#10;                        Icon(Icons.Default.Edit, &quot;Edit Username&quot;)&#10;                    }&#10;                }&#10;            )&#10;        },&#10;        snackbarHost = { SnackbarHost(snackbarHostState) }&#10;    ) { padding -&gt;&#10;        Column(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .padding(padding)&#10;                .padding(horizontal = 16.dp, vertical = 8.dp)&#10;        ) {&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) {&#10;                        CircularProgressIndicator()&#10;                    }&#10;                }&#10;                error != null -&gt; {&#10;                    Box(&#10;                        contentAlignment = Alignment.Center,&#10;                        modifier = Modifier.fillMaxSize()&#10;                    ) {&#10;                        Text(&#10;                            text = error!!,&#10;                            color = MaterialTheme.colorScheme.error,&#10;                            modifier = Modifier.padding(16.dp)&#10;                        )&#10;                    }&#10;                }&#10;                leaderboardState != null -&gt; {&#10;                    LazyColumn(&#10;                        modifier = Modifier.weight(1f),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        itemsIndexed(leaderboardState!!.top) { index, entry -&gt;&#10;                            Card(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                colors = CardDefaults.cardColors(&#10;                                    containerColor = when {&#10;                                        entry.user_id == leaderboardService.getUserId() -&gt; MaterialTheme.colorScheme.primaryContainer&#10;                                        index == 0 -&gt; goldColor&#10;                                        index == 1 -&gt; silverColor&#10;                                        index == 2 -&gt; bronzeColor&#10;                                        else -&gt; MaterialTheme.colorScheme.surfaceVariant&#10;                                    }&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(16.dp),&#10;                                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    Row(&#10;                                        horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                                        verticalAlignment = Alignment.CenterVertically&#10;                                    ) {&#10;                                        Text(&#10;                                            text = &quot;#${index + 1}&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium,&#10;                                            fontWeight = FontWeight.Bold&#10;                                        )&#10;                                        Text(&#10;                                            text = entry.username,&#10;                                            style = MaterialTheme.typography.titleMedium&#10;                                        )&#10;                                    }&#10;                                    Text(&#10;                                        text = entry.score.toString(),&#10;                                        style = MaterialTheme.typography.titleLarge,&#10;                                        fontWeight = FontWeight.Bold&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Show user's position if not in top 10&#10;                    if (!leaderboardState!!.inTop &amp;&amp; leaderboardState!!.position != null) {&#10;                        Spacer(modifier = Modifier.height(16.dp))&#10;                        Card(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = MaterialTheme.colorScheme.primaryContainer&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(16.dp),&#10;                                horizontalArrangement = Arrangement.SpaceBetween,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;Your Position: #${leaderboardState!!.position}&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium&#10;                                )&#10;                                Text(&#10;                                    text = leaderboardState!!.score.toString(),&#10;                                    style = MaterialTheme.typography.titleLarge,&#10;                                    fontWeight = FontWeight.Bold&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        UsernameDialog(&#10;            leaderboardService = leaderboardService,&#10;            currentUsername = currentUsername,&#10;            isOpen = showUsernameDialog,&#10;            onDismiss = { showUsernameDialog = false },&#10;            onSuccess = { newUsername -&gt;&#10;                currentUsername = newUsername&#10;                showUsernameDialog = false&#10;                scope.launch {&#10;                    snackbarHostState.showSnackbar(&#10;                        message = &quot;Username updated successfully&quot;,&#10;                        duration = SnackbarDuration.Short&#10;                    )&#10;                }&#10;            },&#10;            onError = { errorMessage -&gt;&#10;                scope.launch {&#10;                    snackbarHostState.showSnackbar(&#10;                        message = errorMessage,&#10;                        duration = SnackbarDuration.Long&#10;                    )&#10;                }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class, ExperimentalComposeUiApi::class)&#10;@Composable&#10;fun UsernameDialog(&#10;    leaderboardService: LeaderboardService,&#10;    currentUsername: String?,&#10;    isOpen: Boolean,&#10;    onDismiss: () -&gt; Unit,&#10;    onSuccess: (String) -&gt; Unit,&#10;    onError: (String) -&gt; Unit&#10;) {&#10;    var username by remember(currentUsername) { mutableStateOf(currentUsername ?: &quot;&quot;) }&#10;    var isChecking by remember { mutableStateOf(false) }&#10;    var isAvailable by remember { mutableStateOf(true) }&#10;    var errorMessage by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isSaving by remember { mutableStateOf(false) }&#10;    val keyboardController = LocalSoftwareKeyboardController.current&#10;    val scope = rememberCoroutineScope()&#10;    var checkJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;&#10;    // Check username availability with debounce&#10;    LaunchedEffect(username) {&#10;        if (username.length &gt;= 3 &amp;&amp; username != currentUsername) {&#10;            // Cancel any existing check&#10;            checkJob?.cancel()&#10;&#10;            // Only show checking state if the check takes longer than 500ms&#10;            val showLoadingJob = launch {&#10;                delay(500)&#10;                isChecking = true&#10;            }&#10;&#10;            checkJob = launch {&#10;                delay(600) // Debounce delay&#10;                try {&#10;                    leaderboardService.checkUsernameAvailability(username)&#10;                        .onSuccess { available -&gt;&#10;                            isAvailable = available&#10;                            errorMessage = if (!available) &quot;Username is already taken&quot; else null&#10;                        }&#10;                        .onFailure {&#10;                            // Don't show network errors while typing&#10;                            isAvailable = false&#10;                        }&#10;                } finally {&#10;                    showLoadingJob.cancel()&#10;                    isChecking = false&#10;                }&#10;            }&#10;        } else {&#10;            checkJob?.cancel()&#10;            isChecking = false&#10;            // Only show validation errors for short usernames&#10;            errorMessage = when {&#10;                username.isEmpty() -&gt; null&#10;                username.length &lt; 3 -&gt; &quot;Username must be at least 3 characters&quot;&#10;                username.length &gt; 20 -&gt; &quot;Username must be less than 20 characters&quot;&#10;                !username.matches(Regex(&quot;^[a-zA-Z0-9_]+$&quot;)) -&gt;&#10;                    &quot;Only letters, numbers, and underscores allowed&quot;&#10;                else -&gt; null&#10;            }&#10;        }&#10;    }&#10;&#10;    if (isOpen) {&#10;        AlertDialog(&#10;            onDismissRequest = { if (!isSaving) onDismiss() },&#10;            title = { Text(&quot;Set Username&quot;) },&#10;            text = {&#10;                Column {&#10;                    OutlinedTextField(&#10;                        value = username,&#10;                        onValueChange = { newUsername -&gt;&#10;                            username = newUsername&#10;                            errorMessage = when {&#10;                                newUsername.length &lt; 3 -&gt; &quot;Username must be at least 3 characters&quot;&#10;                                newUsername.length &gt; 20 -&gt; &quot;Username must be less than 20 characters&quot;&#10;                                !newUsername.matches(Regex(&quot;^[a-zA-Z0-9_]+$&quot;)) -&gt;&#10;                                    &quot;Only letters, numbers, and underscores allowed&quot;&#10;                                else -&gt; null&#10;                            }&#10;                        },&#10;                        label = { Text(&quot;Username&quot;) },&#10;                        singleLine = true,&#10;                        isError = errorMessage != null,&#10;                        enabled = !isSaving,&#10;                        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Done),&#10;                        keyboardActions = KeyboardActions(onDone = { keyboardController?.hide() }),&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        trailingIcon = if (isChecking) {&#10;                            {&#10;                                CircularProgressIndicator(&#10;                                    modifier = Modifier.size(24.dp),&#10;                                    strokeWidth = 2.dp&#10;                                )&#10;                            }&#10;                        } else null&#10;                    )&#10;                    if (errorMessage != null) {&#10;                        Text(&#10;                            text = errorMessage!!,&#10;                            color = MaterialTheme.colorScheme.error,&#10;                            style = MaterialTheme.typography.bodySmall,&#10;                            modifier = Modifier.padding(top = 4.dp)&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            confirmButton = {&#10;                Button(&#10;                    onClick = {&#10;                        scope.launch {&#10;                            isSaving = true&#10;                            try {&#10;                                leaderboardService.setUsername(username)&#10;                                    .onSuccess {&#10;                                        onSuccess(username)&#10;                                    }&#10;                                    .onFailure { e -&gt;&#10;                                        onError(e.message ?: &quot;Failed to update username&quot;)&#10;                                    }&#10;                            } catch (e: Exception) {&#10;                                onError(&quot;Network error while updating username&quot;)&#10;                            } finally {&#10;                                isSaving = false&#10;                            }&#10;                        }&#10;                    },&#10;                    enabled = errorMessage == null &amp;&amp;&#10;                             username.isNotEmpty() &amp;&amp;&#10;                             !isChecking &amp;&amp;&#10;                             !isSaving &amp;&amp;&#10;                             (username == currentUsername || isAvailable)&#10;                ) {&#10;                    if (isSaving) {&#10;                        CircularProgressIndicator(&#10;                            modifier = Modifier.size(20.dp),&#10;                            strokeWidth = 2.dp&#10;                        )&#10;                    } else {&#10;                        Text(&quot;Save&quot;)&#10;                    }&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(&#10;                    onClick = onDismiss,&#10;                    enabled = !isSaving&#10;                ) {&#10;                    Text(&quot;Cancel&quot;)&#10;                }&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/pong_preview.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/pong_preview.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;200dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;200&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FFFFFF&quot;&#10;        android:strokeColor=&quot;#FFFFFF&quot;&#10;        android:strokeWidth=&quot;2&quot;&#10;        android:pathData=&quot;M20,20h160v160h-160z&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/pong_square.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/pong_square.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;200dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;200&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FFFFFF&quot;&#10;        android:pathData=&quot;M0,0h200v200h-200z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/font/space_grotesk.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/font/space_grotesk.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;font-family xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&#10;    &lt;font app:font=&quot;@font/space_grotesk&quot;&#10;          app:fontStyle=&quot;normal&quot;&#10;          app:fontWeight=&quot;400&quot; /&gt;&#10;&lt;/font-family&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>