<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/PongSettings.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/PongSettings.kt" />
              <option name="updatedContent" value="package com.nothinglondon.pong&#10;&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.runtime.mutableStateOf&#10;import androidx.compose.runtime.setValue&#10;&#10;object PongSettings {&#10;    var soundEnabled by mutableStateOf(true)&#10;    var hapticEnabled by mutableStateOf(true)&#10;    var howToPlayExpanded by mutableStateOf(false)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/toys/pong/PongGameService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/pong/toys/pong/PongGameService.kt" />
              <option name="originalContent" value="package com.nothinglondon.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.pong.PongSettings&#10;import com.nothinglondon.pong.R&#10;import com.nothinglondon.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.pong.toys.pong.game.GameState&#10;import com.nothinglondon.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 150L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.3f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;&#10;        // Store previous position for collision detection&#10;        val prevX = ball.x&#10;        val prevY = ball.y&#10;&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24)&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the non-scoring zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside non-scoring zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][x] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nothinglondon.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.pong.PongSettings&#10;import com.nothinglondon.pong.R&#10;import com.nothinglondon.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.pong.toys.pong.game.GameState&#10;import com.nothinglondon.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 150L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.3f&#10;&#10;        // Wall constants&#10;        private val TOP_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 1) }.toSet()&#10;        private val BOTTOM_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 23) }.toSet()&#10;        private val ALL_WALL_CELLS = TOP_WALL_CELLS + BOTTOM_WALL_CELLS&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Check for collisions with specific wall cells&#10;        var hitWall = false&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val checkX = (ballLeft + dx).toInt()&#10;                val checkY = (ballTop + dy).toInt()&#10;                if (ALL_WALL_CELLS.contains(Pair(checkX, checkY))) {&#10;                    hitWall = true&#10;                    break&#10;                }&#10;            }&#10;            if (hitWall) break&#10;        }&#10;&#10;        if (hitWall) {&#10;            ball.reverseY()&#10;            // Move ball away from wall to prevent sticking&#10;            if (ballTop &lt;= 2) { // Near top wall&#10;                ball.y = 2f&#10;            } else { // Near bottom wall&#10;                ball.y = 22f - BALL_SIZE&#10;            }&#10;            return&#10;        }&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24) - only score if not in wall area&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the wall zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside wall zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][x] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/Ball.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/Ball.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;data class Ball(&#10;    var x: Float = 12f,  // Start in center&#10;    var y: Float = 12f,&#10;    var velocityX: Float = 0.2f,&#10;    var velocityY: Float = 0.2f&#10;) {&#10;    fun update() {&#10;        x += velocityX&#10;        y += velocityY&#10;    }&#10;&#10;    fun reverseX() {&#10;        velocityX = -velocityX&#10;    }&#10;&#10;    fun reverseY() {&#10;        velocityY = -velocityY&#10;    }&#10;&#10;    fun getPosition(): Pair&lt;Int, Int&gt; = Pair(x.toInt(), y.toInt())&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt" />
              <option name="originalContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt.new">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/PongGameService.kt.new" />
              <option name="originalContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 45f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.01f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                isPlaying = true&#10;                gameState = GameState.PLAYING&#10;                ball.start()&#10;                updateDisplay()  // Ensure immediate update&#10;            }&#10;            GameState.PLAYING -&gt; {&#10;                // Calibrate using the roll axis as before&#10;                SensorManager.getRotationMatrixFromVector(rotationMatrix, orientationAngles)&#10;                SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;                calibrationAngle = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1  // Center position&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Calculate scroll positions for two copies of the text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;  // Added padding&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 2)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy immediately after the first&#10;            val x2 = x1 + textWidth&#10;            drawText(matrix, scrollText, x2, 16)&#10;&#10;            // Update scroll position&#10;            startScreenScrollPosition += SCROLL_SPEED&#10;            if (startScreenScrollPosition &gt;= textWidth) {&#10;                startScreenScrollPosition = 0f&#10;            }&#10;&#10;            // Send the matrix to display&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;&#10;            // Keep updating the display for scrolling text&#10;            if (gameState == GameState.START_SCREEN) {&#10;                gameScope.launch {&#10;                    delay(16)&#10;                    updateDisplay()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            val pitch = Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // -20 to 20&#10;            val roll = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()   // -180 to 180&#10;&#10;            // Base movement from pitch with reduced range&#10;            val normalizedPitch = (pitch.coerceIn(-20f, 20f) + 20f) / 40f  // 0 to 1&#10;            val basePitchPosition = normalizedPitch * (paddlePositions.size - 1)&#10;&#10;            // Update paddle position&#10;            pointerIndex = basePitchPosition.roundToInt()&#10;                .coerceIn(0, paddlePositions.size - 1)&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.nothinglondon.sdkdemo.demos.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.nothinglondon.sdkdemo.demos.pong.game.GameState&#10;import com.nothinglondon.sdkdemo.demos.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;    private var calibrationAngle: Float = 0f&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val SMOOTHING_FACTOR = 0.9f    // Increased smoothing for more stable movement&#10;        private const val BOT_ERROR_CHANCE = 0.3  // 30% chance of bot making a mistake&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Bot reaction delay in milliseconds&#10;        private const val SCROLL_RESET_POSITION = 45f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.01f&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var score = 0&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // Paddle settings&#10;    private val GYRO_THRESHOLD = 0.1f  // Increased threshold to require more tilt&#10;&#10;    // Paddle sensitivity (edit this for your use case)&#10;    private var paddleSensitivity: Float = 0.3f // Lower = less sensitive, try 0.3-0.7&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;        Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;    private var paddleVelocity: Float = 0f         // Current velocity along the track&#10;&#10;    // Vibrator for haptic feedback&#10;    private var vibrationEnabled = true&#10;&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        startGameLoop()&#10;        updateDisplay()&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                isPlaying = true&#10;                gameState = GameState.PLAYING&#10;                ball.start()&#10;                updateDisplay()  // Ensure immediate update&#10;            }&#10;            GameState.PLAYING -&gt; {&#10;                // Calibrate using the roll axis as before&#10;                SensorManager.getRotationMatrixFromVector(rotationMatrix, orientationAngles)&#10;                SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;                calibrationAngle = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Check wall collisions (top and bottom only)&#10;        if (ball.y &lt;= 0 || ball.y &gt;= MATRIX_SIZE - BALL_SIZE) {&#10;            ball.reverseY()&#10;        }&#10;&#10;        // Check each ball pixel for net/paddle collisions&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val ballX = ball.x + dx&#10;                val ballY = ball.y + dy&#10;&#10;                // Check player side net&#10;                for (i in paddlePositions.indices) {&#10;                    val (netX, netY) = paddlePositions[i]&#10;                    if (isNearPoint(ballX, ballY, netX.toFloat(), netY.toFloat())) {&#10;                        if (i in (pointerIndex - 2)..(pointerIndex + 2)) {&#10;                            // Ball hit player paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[pointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - bot scores&#10;                            resetAfterPoint(false)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Check bot side net (mirrored)&#10;                for (i in paddlePositions.indices) {&#10;                    val (x, y) = paddlePositions[i]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    if (isNearPoint(ballX, ballY, botX.toFloat(), y.toFloat())) {&#10;                        if (i in (botPointerIndex - 2)..(botPointerIndex + 2)) {&#10;                            // Ball hit bot paddle&#10;                            ball.reverseX()&#10;                            ball.velocityY = (ballY - paddlePositions[botPointerIndex].second) * 0.1f&#10;                            vibrate(50)&#10;                            return&#10;                        } else {&#10;                            // Ball went through net - player scores&#10;                            resetAfterPoint(true)&#10;                            return&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= 1.0&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;        // Smoothly move bot paddle toward target&#10;        if (botPointerIndex &lt; botTargetIndex) botPointerIndex++&#10;        else if (botPointerIndex &gt; botTargetIndex) botPointerIndex--&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1  // Center position&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Calculate scroll positions for two copies of the text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;  // Added padding&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 2)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy immediately after the first&#10;            val x2 = x1 + textWidth&#10;            drawText(matrix, scrollText, x2, 16)&#10;&#10;            // Update scroll position&#10;            startScreenScrollPosition += SCROLL_SPEED&#10;            if (startScreenScrollPosition &gt;= textWidth) {&#10;                startScreenScrollPosition = 0f&#10;            }&#10;&#10;            // Send the matrix to display&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;&#10;            // Keep updating the display for scrolling text&#10;            if (gameState == GameState.START_SCREEN) {&#10;                gameScope.launch {&#10;                    delay(16)&#10;                    updateDisplay()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            val pitch = Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // -90 to 90&#10;            val roll = Math.toDegrees(orientationAngles[2].toDouble()).toFloat()   // -180 to 180&#10;&#10;            // Adjust roll based on calibration&#10;            val adjustedRoll = (roll - calibrationAngle).coerceIn(-90f, 90f)&#10;            &#10;            // Combine pitch and roll for more natural movement&#10;            val combinedAngle = (pitch * 0.7f + adjustedRoll * 0.3f).coerceIn(-45f, 45f)&#10;            &#10;            // Normalize to 0-1 range with smooth acceleration&#10;            val normalizedPosition = ((combinedAngle + 45f) / 90f).coerceIn(0f, 1f)&#10;            &#10;            // Apply smoothing using paddlePosition and velocity&#10;            val targetPosition = normalizedPosition * (paddlePositions.size - 1)&#10;            val distance = targetPosition - paddlePosition&#10;            &#10;            // Update velocity with smoothing&#10;            paddleVelocity = paddleVelocity * SMOOTHING_FACTOR + distance * (1 - SMOOTHING_FACTOR)&#10;            paddlePosition = (paddlePosition + paddleVelocity).coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;            &#10;            // Update pointer index from smoothed position&#10;            pointerIndex = paddlePosition.roundToInt().coerceIn(0, paddlePositions.size - 1)&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -45 and 45 degrees for initial direction&#10;            val angle = Math.toRadians((Math.random() * 90 - 45).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (INITIAL_BALL_SPEED * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (INITIAL_BALL_SPEED * Math.sin(angle)).toFloat()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-1f, 1f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/GameState.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/GameState.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong.game&#10;&#10;enum class GameState {&#10;    START_SCREEN,    // Showing level information&#10;    PLAYING,         // Active game&#10;    LEVEL_UP,       // Player won&#10;    GAME_OVER,      // Player lost&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/LevelManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/nothinglondon/sdkdemo/demos/pong/game/LevelManager.kt" />
              <option name="updatedContent" value="package com.nothinglondon.sdkdemo.demos.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class LevelManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongGame&quot;, Context.MODE_PRIVATE)&#10;    &#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        get() = prefs.getInt(&quot;highest_level&quot;, 0)&#10;        private set(value) = prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 15% for levels 1-5, then decrease by 0.5% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.15f&#10;            else -&gt; maxOf(0.01f, 0.15f - (currentLevel - 5) * 0.005f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/PongApplication.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/PongApplication.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/firebase/FirebaseManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/firebase/FirebaseManager.kt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardEntry.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardEntry.kt" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardScreen.kt" />
              <option name="originalContent" value="            )&#10;    }&#10;}&#10;}&#10;}&#10;" />
              <option name="updatedContent" value="            )&#10;    }&#10;}&#10;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/leaderboard/LeaderboardService.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/PongGameService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/PongGameService.kt" />
              <option name="originalContent" value="package com.thomasp.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.thomasp.pong.PongSettings&#10;import com.thomasp.pong.R&#10;import com.thomasp.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.thomasp.pong.toys.pong.game.GameState&#10;import com.thomasp.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.5f&#10;&#10;        // Wall constants&#10;        private val TOP_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 1) }.toSet()&#10;        private val BOTTOM_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 23) }.toSet()&#10;        private val ALL_WALL_CELLS = TOP_WALL_CELLS + BOTTOM_WALL_CELLS&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    // Add new variables for smooth movement&#10;    private var botCurrentPosition: Float = BOT_PADDLE_START_INDEX.toFloat()&#10;    private val BOT_MOVEMENT_SPEED = 0.15f  // Adjust this value to change smoothness&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Check for collisions with specific wall cells&#10;        var hitWall = false&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val checkX = (ballLeft + dx).toInt()&#10;                val checkY = (ballTop + dy).toInt()&#10;                if (ALL_WALL_CELLS.contains(Pair(checkX, checkY))) {&#10;                    hitWall = true&#10;                    break&#10;                }&#10;            }&#10;            if (hitWall) break&#10;        }&#10;&#10;        if (hitWall) {&#10;            ball.reverseY()&#10;            // Move ball away from wall to prevent sticking&#10;            if (ballTop &lt;= 2) { // Near top wall&#10;                ball.y = 2f&#10;            } else { // Near bottom wall&#10;                ball.y = 22f - BALL_SIZE&#10;            }&#10;            return&#10;        }&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24) - only score if not in wall area&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the wall zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside wall zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;&#10;        // Smoothly interpolate the bot's position&#10;        val diff = botTargetIndex - botCurrentPosition&#10;        if (diff != 0f) {&#10;            botCurrentPosition += diff * BOT_MOVEMENT_SPEED&#10;            botPointerIndex = botCurrentPosition.roundToInt().coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val levelText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Level&quot;)&#10;                .setPosition(2, 7)&#10;                .build()&#10;&#10;            val upText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Up&quot;)&#10;                .setPosition(8, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(levelText)&#10;                .addLow(upText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val youText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;You&quot;)&#10;                .setPosition(5, 7)&#10;                .build()&#10;&#10;            val loseText = GlyphMatrixObject.Builder()&#10;                .setText(&quot;Lose&quot;)&#10;                .setPosition(3, 13)&#10;                .build()&#10;&#10;            val frame = GlyphMatrixFrame.Builder()&#10;                .addTop(youText)&#10;                .addLow(loseText)&#10;                .build(applicationContext)&#10;&#10;            manager.setMatrixFrame(frame.render())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.toys.pong&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import android.media.AudioAttributes&#10;import android.media.SoundPool&#10;import android.os.VibrationEffect&#10;import android.os.Vibrator&#10;import com.thomasp.pong.PongSettings&#10;import com.thomasp.pong.R&#10;import com.thomasp.pong.toys.GlyphMatrixService&#10;import com.nothing.ketchum.GlyphMatrixManager&#10;import com.nothing.ketchum.GlyphMatrixFrame&#10;import com.nothing.ketchum.GlyphMatrixObject&#10;import com.thomasp.pong.toys.pong.game.GameState&#10;import com.thomasp.pong.toys.pong.game.LevelManager&#10;import kotlinx.coroutines.*&#10;import kotlin.math.roundToInt&#10;&#10;class PongGameService : GlyphMatrixService(&quot;Pong-Game&quot;), SensorEventListener {&#10;    private lateinit var levelManager: LevelManager&#10;    private var gameState: GameState = GameState.START_SCREEN&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private val gameScope = CoroutineScope(Dispatchers.Default)&#10;    private var gameLoop: Job? = null&#10;    private var isGameRunning = false&#10;    private val ball = Ball()&#10;    private var vibrator: Vibrator? = null&#10;&#10;    // Sensor and paddle control variables&#10;    private var rotationSensor: Sensor? = null&#10;    private val rotationMatrix = FloatArray(9)&#10;    private val orientationAngles = FloatArray(3)&#10;&#10;    // Bot AI variables&#10;    private var botPointerIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var lastReactionTime: Long = 0L&#10;    private var botTargetIndex: Int = BOT_PADDLE_START_INDEX&#10;    private var botShouldMakeMistake: Boolean = false&#10;    private var botMistakeError: Int = 0&#10;    private var lastBallDirection: Float = 0f&#10;&#10;    // Sound variables&#10;    private var soundPool: SoundPool? = null&#10;    private var isPlayingSound = false&#10;    private var userHitSoundId = 0&#10;    private var botHitSoundId = 0&#10;    private var winSoundId = 0&#10;    private var loseSoundId = 0&#10;&#10;    companion object {&#10;        private const val MATRIX_SIZE = 25&#10;        private const val DEVICE_PHONE3 = &quot;23112&quot;&#10;        private const val FRAME_RATE = 60L&#10;        private const val FRAME_TIME = 1000L / FRAME_RATE&#10;        private const val INITIAL_BALL_SPEED = 0.2f  // Increased from 0.1f&#10;        private const val BOT_PADDLE_START_INDEX = 13  // Center position for bot paddle&#10;        private const val BOT_PADDLE_OPACITY = 128  // 50% opacity&#10;        private const val BALL_SIZE = 2  // 2x2 pixel ball&#10;        private const val BOT_ERROR_CHANCE = 0.15f  // Reduced from 0.3 for better initial performance&#10;        private const val BOT_REACTION_DELAY_MS = 200L  // Reduced from 200ms for quicker reactions&#10;        private const val SCROLL_RESET_POSITION = 80f  // Position to reset scroll&#10;        private const val SCROLL_START_X = 25  // Where text starts scrolling from&#10;        private const val SCROLL_SPEED = 0.2f&#10;        private const val MIN_X_VELOCITY = 0.5f&#10;&#10;        // Wall constants&#10;        private val TOP_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 1) }.toSet()&#10;        private val BOTTOM_WALL_CELLS = (9..15).map { x -&gt; Pair(x, 23) }.toSet()&#10;        private val ALL_WALL_CELLS = TOP_WALL_CELLS + BOTTOM_WALL_CELLS&#10;&#10;        // Font system constants&#10;        private const val CHAR_WIDTH = 3&#10;        private const val CHAR_HEIGHT = 5&#10;        private const val CHAR_SPACING = 1&#10;&#10;        // Font definition - each character is 3x5 pixels&#10;        private val FONT_CHARS = mapOf(&#10;            'A' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'B' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'C' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'D' to arrayOf(&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,0)&#10;            ),&#10;            'E' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'F' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'G' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'H' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'I' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'L' to arrayOf(&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'N' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1)&#10;            ),&#10;            'O' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'P' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,0,0)&#10;            ),&#10;            'U' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            'V' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            ' ' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '-' to arrayOf(&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,0),&#10;                intArrayOf(0,0,0)&#10;            ),&#10;            '0' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '1' to arrayOf(&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '2' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '3' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '4' to arrayOf(&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,0,1)&#10;            ),&#10;            '5' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '6' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,0),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '7' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0),&#10;                intArrayOf(0,1,0)&#10;            ),&#10;            '8' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1)&#10;            ),&#10;            '9' to arrayOf(&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(1,0,1),&#10;                intArrayOf(1,1,1),&#10;                intArrayOf(0,0,1),&#10;                intArrayOf(1,1,1)&#10;            )&#10;        )&#10;    }&#10;&#10;    // Game settings&#10;    private var isPlaying = false&#10;    private var pointerIndex: Int = 13&#10;&#10;    // List of LED coordinates for the left edge (from bottom to top)&#10;    private val paddlePositions = mutableListOf(&#10;        Pair(8, 23),  // Bottom&#10;        Pair(7, 23),&#10;        Pair(6, 22),&#10;        Pair(5, 22),&#10;        Pair(4, 21),&#10;        Pair(3, 20),&#10;        Pair(2, 19),&#10;        Pair(2, 18),&#10;        Pair(1, 17),&#10;        Pair(1, 16),&#10;        Pair(0, 15),&#10;        Pair(0, 14),&#10;        Pair(0, 13),&#10;        Pair(0, 12),  // Starting position (center)&#10;        Pair(0, 11),&#10;        Pair(0, 10),&#10;        Pair(0, 9),&#10;        Pair(1, 8),&#10;        Pair(1, 7),&#10;            Pair(2, 6),&#10;        Pair(2, 5),&#10;        Pair(3, 4),&#10;        Pair(4, 3),&#10;        Pair(5, 2),&#10;        Pair(6, 2),&#10;        Pair(7, 1),&#10;        Pair(8, 1)    // Top&#10;    )&#10;&#10;    // Physics state for paddle movement&#10;    private var paddlePosition: Float = 13f         // Position along the track (0 to paddlePositions.size-1)&#10;&#10;    private var scrollJob: Job? = null&#10;    private var startScreenScrollPosition = 0f&#10;&#10;    // Add new variables for smooth movement&#10;    private var botCurrentPosition: Float = BOT_PADDLE_START_INDEX.toFloat()&#10;    private val BOT_MOVEMENT_SPEED = 0.15f  // Adjust this value to change smoothness&#10;&#10;    override fun performOnServiceConnected(context: Context, glyphMatrixManager: GlyphMatrixManager) {&#10;        glyphMatrixManager.register(DEVICE_PHONE3)&#10;        vibrator = context.getSystemService(Vibrator::class.java)&#10;        levelManager = LevelManager(context)&#10;        setupSensors(context)&#10;        setupSoundPool(context)&#10;        startGameLoop()&#10;        startScrollingText()&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun setupSoundPool(context: Context) {&#10;        val audioAttributes = AudioAttributes.Builder()&#10;            .setUsage(AudioAttributes.USAGE_GAME)&#10;            .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)&#10;            .build()&#10;&#10;        soundPool = SoundPool.Builder()&#10;            .setMaxStreams(1)  // Only allow one sound at a time&#10;            .setAudioAttributes(audioAttributes)&#10;            .build()&#10;&#10;        // Load sound effects&#10;        userHitSoundId = soundPool?.load(context, R.raw.user_hit, 1) ?: 0&#10;        botHitSoundId = soundPool?.load(context, R.raw.bot_hit, 1) ?: 0&#10;        winSoundId = soundPool?.load(context, R.raw.win, 1) ?: 0&#10;        loseSoundId = soundPool?.load(context, R.raw.lose, 1) ?: 0&#10;    }&#10;&#10;    private fun playSound(soundId: Int) {&#10;        if (!isPlayingSound &amp;&amp; soundId != 0 &amp;&amp; PongSettings.soundEnabled) {&#10;            isPlayingSound = true&#10;            soundPool?.play(soundId, 1f, 1f, 1, 0, 1f)&#10;            gameScope.launch {&#10;                delay(100) // Prevent new sounds for 100ms&#10;                isPlayingSound = false&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun performOnServiceDisconnected(context: Context) {&#10;        stopGame()&#10;        stopScrollingText()&#10;        sensorManager?.unregisterListener(this)&#10;        gameScope.cancel()&#10;&#10;        // Release sound pool&#10;        soundPool?.release()&#10;        soundPool = null&#10;    }&#10;&#10;    override fun onTouchPointLongPress() {&#10;        when (gameState) {&#10;            GameState.START_SCREEN -&gt; {&#10;                stopScrollingText()&#10;                gameState = GameState.PLAYING&#10;                isPlaying = true&#10;                ball.start()&#10;                vibrate(50)&#10;                updateDisplay()&#10;            }&#10;            GameState.LEVEL_UP, GameState.GAME_OVER -&gt; {&#10;                gameState = GameState.START_SCREEN&#10;                startScrollingText()&#10;                updateDisplay()&#10;            }&#10;            else -&gt; { }&#10;        }&#10;    }&#10;&#10;    private fun startGameLoop() {&#10;        if (!isGameRunning) {&#10;            isGameRunning = true&#10;            gameLoop = gameScope.launch {&#10;                while (isActive &amp;&amp; isGameRunning) {&#10;                    if (isPlaying) {&#10;                        updateGame()&#10;                    }&#10;                    updateDisplay()&#10;                    delay(FRAME_TIME)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopGame() {&#10;        isGameRunning = false&#10;        gameLoop?.cancel()&#10;    }&#10;&#10;    private fun updateGame() {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        // Update ball speed based on level&#10;        val speedMultiplier = levelManager.getBallSpeedMultiplier()&#10;        ball.update(speedMultiplier)&#10;&#10;        // Update bot error chance based on level&#10;        val botErrorChance = levelManager.getBotErrorPercentage()&#10;&#10;        if (ball.velocityX &gt; 0 &amp;&amp; lastBallDirection &lt;= 0) {&#10;            botShouldMakeMistake = Math.random() &lt; botErrorChance&#10;            botMistakeError = if (botShouldMakeMistake) {&#10;                (Math.random() * 8 - 4).toInt()&#10;            } else 0&#10;        }&#10;        lastBallDirection = ball.velocityX&#10;        updateBotPaddle()&#10;&#10;        // Handle wall collisions and scoring&#10;        val ballLeft = ball.x&#10;        val ballRight = ball.x + BALL_SIZE&#10;        val ballTop = ball.y&#10;        val ballBottom = ball.y + BALL_SIZE&#10;&#10;        // Check for collisions with specific wall cells&#10;        var hitWall = false&#10;        for (dx in 0 until BALL_SIZE) {&#10;            for (dy in 0 until BALL_SIZE) {&#10;                val checkX = (ballLeft + dx).toInt()&#10;                val checkY = (ballTop + dy).toInt()&#10;                if (ALL_WALL_CELLS.contains(Pair(checkX, checkY))) {&#10;                    hitWall = true&#10;                    break&#10;                }&#10;            }&#10;            if (hitWall) break&#10;        }&#10;&#10;        if (hitWall) {&#10;            ball.reverseY()&#10;            // Move ball away from wall to prevent sticking&#10;            if (ballTop &lt;= 2) { // Near top wall&#10;                ball.y = 2f&#10;            } else { // Near bottom wall&#10;                ball.y = 22f - BALL_SIZE&#10;            }&#10;            return&#10;        }&#10;&#10;        // Left wall (x=0) collision - Player loses point&#10;        if (ballLeft &lt;= 0) {&#10;            resetAfterPoint(false)&#10;            return&#10;        }&#10;&#10;        // Right wall (x=24) collision - Player scores point&#10;        if (ballRight &gt;= MATRIX_SIZE) {&#10;            resetAfterPoint(true)&#10;            return&#10;        }&#10;&#10;        // Top and bottom wall collisions (y=0 and y=24) - only score if not in wall area&#10;        if (ballTop &lt;= 0 || ballBottom &gt;= MATRIX_SIZE) {&#10;            // Check if we're in the wall zone (x=9 to x=15)&#10;            if (ballLeft &gt;= 9 &amp;&amp; ballRight &lt;= 15) {&#10;                ball.reverseY()&#10;                // Ensure the ball doesn't get stuck in the wall&#10;                if (ballTop &lt;= 0) {&#10;                    ball.y = 0f&#10;                } else {&#10;                    ball.y = (MATRIX_SIZE - BALL_SIZE).toFloat()&#10;                }&#10;            } else {&#10;                // Outside wall zone, check which player scored&#10;                if (ballLeft &lt; MATRIX_SIZE / 2) {&#10;                    resetAfterPoint(false) // Bot scores&#10;                } else {&#10;                    resetAfterPoint(true)  // Player scores&#10;                }&#10;                return&#10;            }&#10;        }&#10;&#10;        // Check paddle collisions&#10;        // For player paddle (left side)&#10;        if (ball.velocityX &lt; 0) { // Only check when ball is moving towards player&#10;            val paddleRange = (pointerIndex - 2)..(pointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (px, py) = paddlePositions[i]&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballLeft &lt;= (px + 1) &amp;&amp; ballRight &gt;= px &amp;&amp;&#10;                    ballTop &lt;= (py + 1) &amp;&amp; ballBottom &gt;= py) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[pointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = paddlePositions[pointerIndex].first + 1f&#10;                vibrate(50)&#10;                playSound(userHitSoundId)&#10;                return&#10;            }&#10;        }&#10;&#10;        // For bot paddle (right side)&#10;        if (ball.velocityX &gt; 0) { // Only check when ball is moving towards bot&#10;            val paddleRange = (botPointerIndex - 2)..(botPointerIndex + 2)&#10;            var hitPaddle = false&#10;&#10;            for (i in paddleRange) {&#10;                if (i !in paddlePositions.indices) continue&#10;                val (x, y) = paddlePositions[i]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;&#10;                // Check if any part of the ball overlaps with this paddle pixel&#10;                if (ballRight &gt;= botX &amp;&amp; ballLeft &lt;= (botX + 1) &amp;&amp;&#10;                    ballTop &lt;= (y + 1) &amp;&amp; ballBottom &gt;= y) {&#10;                    hitPaddle = true&#10;                    break&#10;                }&#10;            }&#10;&#10;            if (hitPaddle) {&#10;                // Calculate deflection based on where the ball hit relative to paddle center&#10;                val paddleCenterY = paddlePositions[botPointerIndex].second&#10;                val hitOffset = (ballTop + BALL_SIZE / 2) - paddleCenterY&#10;&#10;                // Reverse X direction and ensure it maintains speed&#10;                ball.reverseX()&#10;&#10;                // Calculate Y velocity based on hit position, but ensure it's directed towards opponent&#10;                val hitFactor = (hitOffset * 0.15f).coerceIn(-0.8f, 0.8f)&#10;                ball.velocityY = hitFactor * ball.getCurrentSpeed()&#10;&#10;                // Move ball just outside paddle to prevent multiple hits&#10;                ball.x = (MATRIX_SIZE - 1 - paddlePositions[botPointerIndex].first - BALL_SIZE - 1f)&#10;                vibrate(50)&#10;                playSound(botHitSoundId)&#10;                return&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun isNearPoint(x1: Float, y1: Float, x2: Float, y2: Float, tolerance: Float = 1.0f): Boolean {&#10;        val dx = x1 - x2&#10;        val dy = y1 - y2&#10;        return Math.sqrt((dx * dx + dy * dy).toDouble()) &lt;= tolerance.toDouble()&#10;    }&#10;&#10;    private fun vibrate(duration: Long) {&#10;        if (!PongSettings.hapticEnabled) return&#10;&#10;        vibrator?.let { v -&gt;&#10;            if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.O) {&#10;                v.vibrate(VibrationEffect.createOneShot(duration, VibrationEffect.DEFAULT_AMPLITUDE))&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                v.vibrate(duration)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun updateBotPaddle() {&#10;        val now = System.currentTimeMillis()&#10;        if (now - lastReactionTime &gt;= BOT_REACTION_DELAY_MS) {&#10;            lastReactionTime = now&#10;            // Mirror the ball's Y position for the bot's side&#10;            val ballY = (MATRIX_SIZE - 1 - ball.y).toInt()&#10;            val error = botMistakeError&#10;            botTargetIndex = (ballY + error).coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;&#10;        // Smoothly interpolate the bot's position&#10;        val diff = botTargetIndex - botCurrentPosition&#10;        if (diff != 0f) {&#10;            botCurrentPosition += diff * BOT_MOVEMENT_SPEED&#10;            botPointerIndex = botCurrentPosition.roundToInt().coerceIn(2, paddlePositions.size - 3)&#10;        }&#10;    }&#10;&#10;    private fun resetAfterPoint(playerScored: Boolean) {&#10;        if (playerScored) {&#10;            // Player wins, level up&#10;            gameState = GameState.LEVEL_UP&#10;            isPlaying = false&#10;            ball.reset()&#10;            // Level up only after state changes to prevent race conditions&#10;            levelManager.levelUp()&#10;            vibrate(100) // Victory vibration&#10;            playSound(winSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        } else {&#10;            // Player loses, reset to level 0&#10;            gameState = GameState.GAME_OVER&#10;            isPlaying = false&#10;            ball.reset()&#10;            levelManager.resetToStart()&#10;            vibrate(300) // Longer vibration for loss&#10;            playSound(loseSoundId)&#10;&#10;            // Schedule transition to start screen after 2 seconds&#10;            gameScope.launch {&#10;                delay(2000)&#10;                gameState = GameState.START_SCREEN&#10;                startScreenScrollPosition = 0f  // Reset scroll position&#10;                startScrollingText()  // Restart scrolling&#10;                updateDisplay()&#10;            }&#10;        }&#10;        updateDisplay()&#10;    }&#10;&#10;    private fun updateDisplay() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            when (gameState) {&#10;                GameState.START_SCREEN -&gt; renderStartScreen()&#10;                GameState.PLAYING -&gt; {&#10;                    val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;                    renderGameScreen(matrix)&#10;                    manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;                }&#10;                GameState.LEVEL_UP -&gt; renderLevelUpScreen()&#10;                GameState.GAME_OVER -&gt; renderGameOverScreen()&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun renderLevelUpScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;            &#10;            // Center &quot;LEVEL&quot; text&#10;            drawText(matrix, &quot;LEVEL&quot;, 8, 8)&#10;            // Center &quot;UP&quot; text&#10;            drawText(matrix, &quot;UP&quot;, 14, 16)&#10;            &#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameOverScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;            &#10;            // Center &quot;YOU&quot; text&#10;            drawText(matrix, &quot;YOU&quot;, 12, 8)&#10;            // Center &quot;LOSE&quot; text&#10;            drawText(matrix, &quot;LOSE&quot;, 10, 16)&#10;            &#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun drawChar(matrix: Array&lt;IntArray&gt;, char: Char, x: Int, y: Int, brightness: Int = 255) {&#10;        val charPattern = FONT_CHARS[char.uppercaseChar()] ?: return&#10;        for (py in 0 until CHAR_HEIGHT) {&#10;            for (px in 0 until CHAR_WIDTH) {&#10;                if (charPattern[py][px] == 1) {&#10;                    val matrixX = x + px&#10;                    val matrixY = y + py&#10;                    if (matrixX in 0 until MATRIX_SIZE &amp;&amp; matrixY in 0 until MATRIX_SIZE) {&#10;                        matrix[matrixY][matrixX] = brightness&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun drawText(matrix: Array&lt;IntArray&gt;, text: String, x: Int, y: Int, brightness: Int = 255) {&#10;        var xPos = x&#10;        text.uppercase().forEach { char -&gt;&#10;            if (xPos &lt; MATRIX_SIZE) {&#10;                drawChar(matrix, char, xPos, y, brightness)&#10;            }&#10;            xPos += CHAR_WIDTH + CHAR_SPACING&#10;        }&#10;    }&#10;&#10;    private fun startScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = gameScope.launch {&#10;            while (isActive &amp;&amp; gameState == GameState.START_SCREEN) {&#10;                startScreenScrollPosition += SCROLL_SPEED&#10;                if (startScreenScrollPosition &gt;= SCROLL_RESET_POSITION) {&#10;                    startScreenScrollPosition = 0f&#10;                }&#10;                renderStartScreen()&#10;                delay(16) // ~60fps&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun stopScrollingText() {&#10;        scrollJob?.cancel()&#10;        scrollJob = null&#10;    }&#10;&#10;    private fun renderStartScreen() {&#10;        glyphMatrixManager?.let { manager -&gt;&#10;            val matrix = Array(MATRIX_SIZE) { IntArray(MATRIX_SIZE) }&#10;&#10;            // Draw static paddles&#10;            // Left paddle (player)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;&#10;            // Right paddle (bot)&#10;            for (offset in -2..2) {&#10;                val pos = 13 + offset  // Center position&#10;                if (pos in 0 until paddlePositions.size) {&#10;                    val (x, y) = paddlePositions[pos]&#10;                    val botX = MATRIX_SIZE - 1 - x&#10;                    matrix[y][botX] = BOT_PADDLE_OPACITY&#10;                }&#10;            }&#10;&#10;            // Draw &quot;PONG&quot; text at the top&#10;            drawText(matrix, &quot;PONG&quot;, 5, 4)&#10;&#10;            // Draw static 2x2 ball in the middle&#10;            val ballX = MATRIX_SIZE / 2 - 1&#10;            val ballY = MATRIX_SIZE / 2 - 1&#10;            for (dy in 0 until 2) {&#10;                for (dx in 0 until 2) {&#10;                    matrix[ballY + dy][ballX + dx] = 255&#10;                }&#10;            }&#10;&#10;            // Draw scrolling text&#10;            val scrollText = &quot;LV ${levelManager.currentLevel} - HI ${levelManager.highestLevel}    &quot;&#10;            val textWidth = scrollText.length * (CHAR_WIDTH + 3)&#10;&#10;            // Draw first copy&#10;            val x1 = (SCROLL_START_X - startScreenScrollPosition).toInt()&#10;            drawText(matrix, scrollText, x1, 16)&#10;&#10;            // Draw second copy for seamless loop&#10;            val x2 = x1 + textWidth&#10;            if (x2 &lt; MATRIX_SIZE) {&#10;                drawText(matrix, scrollText, x2, 16)&#10;            }&#10;&#10;            manager.setMatrixFrame(matrix.flatMap { it.asIterable() }.toIntArray())&#10;        }&#10;    }&#10;&#10;    private fun renderGameScreen(matrix: Array&lt;IntArray&gt;) {&#10;        // Draw paddles&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = pointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                matrix[y][x] = 255&#10;            }&#10;        }&#10;&#10;        // Draw bot paddle&#10;        (-2..2).forEach { offset -&gt;&#10;            val pos = botPointerIndex + offset&#10;            if (pos in 0 until paddlePositions.size) {&#10;                val (x, y) = paddlePositions[pos]&#10;                val botX = MATRIX_SIZE - 1 - x&#10;                matrix[y][botX] = BOT_PADDLE_OPACITY&#10;            }&#10;        }&#10;&#10;        // Draw ball&#10;        val (ballX, ballY) = ball.getPosition()&#10;        for (offsetX in 0 until BALL_SIZE) {&#10;            for (offsetY in 0 until BALL_SIZE) {&#10;                val x = ballX + offsetX&#10;                val y = ballY + offsetY&#10;                if (x in 0 until MATRIX_SIZE &amp;&amp; y in 0 until MATRIX_SIZE) {&#10;                    matrix[y][x] = 255&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun setupSensors(context: Context) {&#10;        sensorManager = context.getSystemService(SensorManager::class.java)&#10;        rotationSensor = sensorManager?.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR)&#10;        sensorManager?.registerListener(this, rotationSensor, SensorManager.SENSOR_DELAY_GAME)&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (gameState != GameState.PLAYING) return&#10;&#10;        if (event?.sensor?.type == Sensor.TYPE_GAME_ROTATION_VECTOR) {&#10;            SensorManager.getRotationMatrixFromVector(rotationMatrix, event.values)&#10;            SensorManager.getOrientation(rotationMatrix, orientationAngles)&#10;&#10;            // Invert pitch and use a smaller range for more precise control&#10;            val pitch = -Math.toDegrees(orientationAngles[1].toDouble()).toFloat()  // Now positive = tilt forward&#10;&#10;            // Map pitch from -30 to 30 degrees to paddle position&#10;            val normalizedPitch = (pitch.coerceIn(-30f, 30f) + 30f) / 60f&#10;&#10;            // Invert the position mapping for more natural feel (tilt forward = paddle down)&#10;            val targetPosition = ((1f - normalizedPitch) * (paddlePositions.size - 1))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            // Smooth the movement more aggressively at the extremes&#10;            val smoothingFactor = when {&#10;                paddlePosition &lt; 2 || paddlePosition &gt; paddlePositions.size - 3 -&gt; 0.8f&#10;                else -&gt; 0.6f&#10;            }&#10;&#10;            paddlePosition = (paddlePosition * smoothingFactor + targetPosition * (1 - smoothingFactor))&#10;                .coerceIn(0f, (paddlePositions.size - 1).toFloat())&#10;&#10;            pointerIndex = paddlePosition.roundToInt()&#10;&#10;            if (isPlaying) {&#10;                updateDisplay()&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // Not needed for this implementation&#10;    }&#10;&#10;    private class Ball {&#10;        var x = MATRIX_SIZE / 2f&#10;        var y = MATRIX_SIZE / 2f&#10;        var velocityX = 0f&#10;        var velocityY = 0f&#10;        private var currentSpeed = INITIAL_BALL_SPEED&#10;&#10;        fun reset() {&#10;            x = MATRIX_SIZE / 2f&#10;            y = MATRIX_SIZE / 2f&#10;            velocityX = 0f&#10;            velocityY = 0f&#10;            currentSpeed = INITIAL_BALL_SPEED&#10;        }&#10;&#10;        fun start() {&#10;            // Random angle between -30 and 30 degrees for more horizontal initial direction&#10;            val angle = Math.toRadians((Math.random() * 60 - 30).toDouble())&#10;            // Randomly choose left or right initial direction&#10;            val direction = if (Math.random() &lt; 0.5) 1 else -1&#10;&#10;            velocityX = (currentSpeed * direction * Math.cos(angle)).toFloat()&#10;            velocityY = (currentSpeed * Math.sin(angle)).toFloat()&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun update(speedMultiplier: Float = 1f) {&#10;            if (velocityX != 0f || velocityY != 0f) {&#10;                // Increase speed gradually&#10;                currentSpeed = (currentSpeed * 1.001f).coerceAtMost(0.5f)&#10;&#10;                x += velocityX * speedMultiplier&#10;                y += velocityY * speedMultiplier&#10;                velocityY = velocityY.coerceIn(-0.8f, 0.8f)&#10;            }&#10;        }&#10;&#10;        fun reverseX() {&#10;            velocityX = -velocityX&#10;            normalizeVelocity()&#10;        }&#10;&#10;        fun reverseY() {&#10;            velocityY = -velocityY&#10;            normalizeVelocity()&#10;        }&#10;&#10;        private fun normalizeVelocity() {&#10;            // Calculate current velocity vector magnitude&#10;            val currentMagnitude = Math.sqrt((velocityX * velocityX + velocityY * velocityY).toDouble()).toFloat()&#10;&#10;            // Normalize and scale to current speed&#10;            velocityX = (velocityX / currentMagnitude * currentSpeed)&#10;            velocityY = (velocityY / currentMagnitude * currentSpeed)&#10;&#10;            // Ensure minimum horizontal velocity to prevent vertical bounces&#10;            if (Math.abs(velocityX) &lt; MIN_X_VELOCITY * currentSpeed) {&#10;                val sign = if (velocityX &gt;= 0) 1 else -1&#10;                velocityX = sign * MIN_X_VELOCITY * currentSpeed&#10;                // Recalculate Y velocity to maintain speed&#10;                val maxY = Math.sqrt((currentSpeed * currentSpeed - velocityX * velocityX).toDouble()).toFloat()&#10;                velocityY = velocityY.coerceIn(-maxY, maxY)&#10;            }&#10;        }&#10;&#10;        fun getPosition(): Pair&lt;Int, Int&gt; {&#10;            return Pair(x.toInt(), y.toInt())&#10;        }&#10;&#10;        fun getCurrentSpeed(): Float {&#10;            return currentSpeed&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/game/LevelManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/thomasp/pong/toys/pong/game/LevelManager.kt" />
              <option name="originalContent" value="package com.thomasp.pong.toys.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class LevelManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongGame&quot;, Context.MODE_PRIVATE)&#10;&#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        get() = prefs.getInt(&quot;highest_level&quot;, 0)&#10;        private set(value) = prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 15% for levels 1-5, then decrease by 0.5% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.15f&#10;            else -&gt; maxOf(0.01f, 0.15f - (currentLevel - 5) * 0.005f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.thomasp.pong.toys.pong.game&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;&#10;class LevelManager(context: Context) {&#10;    private val prefs: SharedPreferences = context.getSharedPreferences(&quot;PongGame&quot;, Context.MODE_PRIVATE)&#10;&#10;    var currentLevel: Int&#10;        get() = prefs.getInt(&quot;current_level&quot;, 0)&#10;        set(value) = prefs.edit().putInt(&quot;current_level&quot;, value).apply()&#10;&#10;    var highestLevel: Int&#10;        get() = prefs.getInt(&quot;highest_level&quot;, 0)&#10;        private set(value) = prefs.edit().putInt(&quot;highest_level&quot;, value).apply()&#10;&#10;    fun getBotErrorPercentage(): Float {&#10;        // Start at 40% for level 1, decrease to 25% by level 5, then decrease by 1% per level&#10;        return when {&#10;            currentLevel &lt;= 5 -&gt; 0.40f - (currentLevel - 1) * 0.03f  // 40% -&gt; 25% over first 5 levels&#10;            else -&gt; maxOf(0.01f, 0.25f - (currentLevel - 5) * 0.01f)&#10;        }&#10;    }&#10;&#10;    fun getBallSpeedMultiplier(): Float {&#10;        // Increase speed by 5% per level&#10;        return 1f + (currentLevel * 0.05f)&#10;    }&#10;&#10;    fun levelUp() {&#10;        currentLevel++&#10;        if (currentLevel &gt; highestLevel) {&#10;            highestLevel = currentLevel&#10;        }&#10;    }&#10;&#10;    fun resetToStart() {&#10;        currentLevel = 0&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/pong_preview.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/pong_preview.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;200dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;200&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FFFFFF&quot;&#10;        android:strokeColor=&quot;#FFFFFF&quot;&#10;        android:strokeWidth=&quot;2&quot;&#10;        android:pathData=&quot;M20,20h160v160h-160z&quot; /&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/drawable/pong_square.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/drawable/pong_square.xml" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&#10;    android:width=&quot;200dp&quot;&#10;    android:height=&quot;200dp&quot;&#10;    android:viewportWidth=&quot;200&quot;&#10;    android:viewportHeight=&quot;200&quot;&gt;&#10;    &lt;path&#10;        android:fillColor=&quot;#FFFFFF&quot;&#10;        android:pathData=&quot;M0,0h200v200h-200z&quot;/&gt;&#10;&lt;/vector&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/res/font/space_grotesk.xml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/res/font/space_grotesk.xml" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&#10;&lt;font-family xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;&#10;    &lt;font app:font=&quot;@font/space_grotesk&quot;&#10;          app:fontStyle=&quot;normal&quot;&#10;          app:fontWeight=&quot;400&quot; /&gt;&#10;&lt;/font-family&gt;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>